<!DOCTYPE html>
<html>
<head>
  <title>Stickman Builds Name</title>
  <style>
    canvas { border: 1px solid black; background: #222; }
    body { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #111; color: white; font-family: Arial, sans-serif; }
    input { margin-bottom: 10px; padding: 5px; font-size: 16px; }
  </style>
</head>
<body>
  <input id="nameInput" type="text" placeholder="Enter your name (e.g., RISKY CAHYA)" value="RISKY CAHYA">
  <canvas id="canvas" width="800" height="400"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const nameInput = document.getElementById('nameInput');

    // Stickman properties
    let stickman1 = {
      x: 50,
      y: 300,
      headRadius: 10,
      torsoLength: 30,
      armLength: 15,
      legLength: 20,
      speed: 2,
      jumping: false,
      jumpHeight: 50,
      jumpY: 0,
      leftArmAngle: 0,
      rightArmAngle: 0,
      leftLegAngle: 0,
      rightLegAngle: 0,
      armDirection: 1,
      legDirection: 1,
      action: 'hammering',
      color: '#ff5555' // Red stickman
    };

    let stickman2 = {
      x: 70,
      y: 300,
      headRadius: 10,
      torsoLength: 30,
      armLength: 15,
      legLength: 20,
      speed: 2,
      jumping: false,
      jumpHeight: 50,
      jumpY: 0,
      leftArmAngle: 0,
      rightArmAngle: 0,
      leftLegAngle: 0,
      rightLegAngle: 0,
      armDirection: 1,
      legDirection: 1,
      action: 'placing',
      color: '#55ff55' // Green stickman
    };

    // Pixel letter templates (5x5 grid)
    const letterTemplates = {
      A: [[0,1,1,0,0],[1,0,0,1,0],[1,1,1,1,0],[1,0,0,1,0],[1,0,0,1,0]],
      B: [[1,1,1,0,0],[1,0,0,1,0],[1,1,1,0,0],[1,0,0,1,0],[1,1,1,0,0]],
      C: [[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0]],
      D: [[1,1,1,0,0],[1,0,0,1,0],[1,0,0,1,0],[1,0,0,1,0],[1,1,1,0,0]],
      E: [[1,1,1,1,0],[1,0,0,0,0],[1,1,1,0,0],[1,0,0,0,0],[1,1,1,1,0]],
      F: [[1,1,1,1,0],[1,0,0,0,0],[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0]],
      G: [[1,1,1,1,0],[1,0,0,0,0],[1,0,1,1,0],[1,0,0,1,0],[1,1,1,1,0]],
      H: [[1,0,0,1,0],[1,0,0,1,0],[1,1,1,1,0],[1,0,0,1,0],[1,0,0,1,0]],
      I: [[1,1,1,0,0],[0,1,0,0,0],[0,1,0,0,0],[0,1,0,0,0],[1,1,1,0,0]],
      J: [[1,1,1,1,0],[0,0,1,0,0],[0,0,1,0,0],[1,0,1,0,0],[1,1,1,0,0]],
      K: [[1,0,0,1,0],[1,0,1,0,0],[1,1,0,0,0],[1,0,1,0,0],[1,0,0,1,0]],
      L: [[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0]],
      M: [[1,0,0,1,0],[1,1,1,1,0],[1,0,1,1,0],[1,0,0,1,0],[1,0,0,1,0]],
      N: [[1,0,0,1,0],[1,1,0,1,0],[1,0,1,1,0],[1,0,0,1,0],[1,0,0,1,0]],
      O: [[1,1,1,1,0],[1,0,0,1,0],[1,0,0,1,0],[1,0,0,1,0],[1,1,1,1,0]],
      P: [[1,1,1,0,0],[1,0,0,1,0],[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0]],
      Q: [[1,1,1,1,0],[1,0,0,1,0],[1,0,0,1,0],[1,0,1,1,0],[1,1,1,1,1]],
      R: [[1,1,1,0,0],[1,0,0,1,0],[1,1,1,0,0],[1,0,1,0,0],[1,0,0,1,0]],
      S: [[1,1,1,1,0],[1,0,0,0,0],[1,1,1,1,0],[0,0,0,1,0],[1,1,1,1,0]],
      T: [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
      U: [[1,0,0,1,0],[1,0,0,1,0],[1,0,0,1,0],[1,0,0,1,0],[1,1,1,1,0]],
      V: [[1,0,0,1,0],[1,0,0,1,0],[1,0,0,1,0],[0,1,1,0,0],[0,0,1,0,0]],
      W: [[1,0,0,1,0],[1,0,0,1,0],[1,0,1,1,0],[1,1,1,1,0],[1,0,0,1,0]],
      X: [[1,0,0,1,0],[0,1,1,0,0],[0,0,1,0,0],[0,1,1,0,0],[1,0,0,1,0]],
      Y: [[1,0,0,0,1],[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
      Z: [[1,1,1,1,0],[0,0,0,1,0],[0,1,1,0,0],[1,0,0,0,0],[1,1,1,1,0]],
      ' ': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]
    };

    let name = nameInput.value.toUpperCase();
    let letters = [];
    let letterPositions = [];
    let currentLetterIndex = 0;
    let blockCounter = 0;
    let building = false;
    let finished = false;
    let highFive = false;
    const letterColors = ['#ff5555', '#55ff55', '#5555ff', '#ffff55', '#ff55ff', '#ffaa55', '#55ffaa', '#aa55ff', '#ff55aa', '#55aaff'];

    function updateLetters() {
      name = nameInput.value.toUpperCase().trim();
      letters = name.split('').map(char => letterTemplates[char] || letterTemplates[' ']);
      letterPositions = [];
      let startX = 100;
      for (let i = 0; i < letters.length; i++) {
        letterPositions.push(startX);
        startX += (letters[i][0]?.length || 5) * 10 + 10;
      }
      currentLetterIndex = 0;
      blockCounter = 0;
      building = false;
      finished = false;
      highFive = false;
      stickman1.x = 50;
      stickman2.x = 70;
      stickman1.speed = 2;
      stickman2.speed = 2;
      stickman1.action = 'hammering';
      stickman2.action = 'placing';
    }

    nameInput.addEventListener('input', updateLetters);
    updateLetters();

    function drawStickman(stickman) {
      ctx.save();
      ctx.translate(stickman.x, stickman.y - stickman.jumpY);

      // Head
      ctx.beginPath();
      ctx.arc(0, -stickman.headRadius, stickman.headRadius, 0, Math.PI * 2);
      ctx.fillStyle = stickman.color;
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.stroke();

      // Torso
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, stickman.torsoLength);
      ctx.strokeStyle = stickman.color;
      ctx.lineWidth = 2;
      ctx.stroke();

      // Upper Left Arm
      ctx.save();
      ctx.translate(0, 5);
      ctx.rotate(stickman.leftArmAngle);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-stickman.armLength / 2, 0);
      ctx.stroke();
      // Lower Left Arm
      ctx.translate(-stickman.armLength / 2, 0);
      ctx.rotate(stickman.leftArmAngle * 0.5);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-stickman.armLength / 2, 0);
      ctx.stroke();
      ctx.restore();

      // Upper Right Arm (Hammering or Normal)
      ctx.save();
      ctx.translate(0, 5);
      if (stickman.action === 'hammering' && building) {
        ctx.rotate(stickman.rightArmAngle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(stickman.armLength / 2, 0);
        ctx.stroke();
        // Hammer
        ctx.translate(stickman.armLength / 2, 0);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(5, -5);
        ctx.stroke();
      } else {
        ctx.rotate(stickman.rightArmAngle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(stickman.armLength / 2, 0);
        ctx.stroke();
        // Lower Right Arm
        ctx.translate(stickman.armLength / 2, 0);
        ctx.rotate(-stickman.rightArmAngle * 0.5);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(stickman.armLength / 2, 0);
        ctx.stroke();
      }
      ctx.restore();

      // Upper Left Leg
      ctx.save();
      ctx.translate(0, stickman.torsoLength);
      ctx.rotate(stickman.leftLegAngle);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-stickman.legLength / 2, 0);
      ctx.stroke();
      // Lower Left Leg
      ctx.translate(-stickman.legLength / 2, 0);
      ctx.rotate(stickman.leftLegAngle * 0.5);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-stickman.legLength / 2, 0);
      ctx.stroke();
      ctx.restore();

      // Upper Right Leg
      ctx.save();
      ctx.translate(0, stickman.torsoLength);
      ctx.rotate(stickman.rightLegAngle);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(stickman.legLength / 2, 0);
      ctx.stroke();
      // Lower Right Leg
      ctx.translate(stickman.legLength / 2, 0);
      ctx.rotate(-stickman.rightLegAngle * 0.5);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(stickman.legLength / 2, 0);
      ctx.stroke();
      ctx.restore();

      ctx.restore();
    }

    function drawLetters() {
      for (let l = 0; l <= currentLetterIndex; l++) {
        const letter = letters[l];
        if (!letter) continue;
        const xOffset = letterPositions[l] || 100;
        const color = letterColors[l % letterColors.length];
        for (let row = 0; row < letter.length; row++) {
          for (let col = 0; col < (letter[row]?.length || 5); col++) {
            if (letter[row]?.[col] === 1 && (l < currentLetterIndex || blockCounter > row * (letter[row]?.length || 5) + col)) {
              ctx.fillStyle = color;
              ctx.fillRect(xOffset + col * 10, 200 + row * 10, 10, 10);
              ctx.strokeStyle = '#fff';
              ctx.strokeRect(xOffset + col * 10, 200 + row * 10, 10, 10);
            }
          }
        }
      }
    }

    function updateStickman(stickman) {
      if (!building && !finished) {
        stickman.x += stickman.speed;
        if (stickman.x >= (letterPositions[currentLetterIndex] || 100) - 20) {
          building = true;
          stickman1.speed = 0;
          stickman2.speed = 0;
        }

        // Dynamic arm and leg movement for running
        stickman.leftArmAngle += 0.1 * stickman.armDirection;
        stickman.rightArmAngle -= 0.1 * stickman.armDirection;
        if (stickman.leftArmAngle > 0.7 || stickman.leftArmAngle < -0.7) stickman.armDirection *= -1;

        stickman.leftLegAngle += 0.15 * stickman.legDirection;
        stickman.rightLegAngle -= 0.15 * stickman.legDirection;
        if (stickman.leftLegAngle > 0.5 || stickman.leftLegAngle < -0.5) stickman.legDirection *= -1;

        // Jump
        if (!stickman.jumping && Math.random() < 0.02) {
          stickman.jumping = true;
          stickman.jumpY = 0;
        }
        if (stickman.jumping) {
          stickman.jumpY += 3;
          if (stickman.jumpY >= stickman.jumpHeight) stickman.jumping = false;
          else if (stickman.jumpY <= 0) stickman.jumpY = 0;
        }
      } else if (building) {
        // Hammering animation
        if (stickman.action === 'hammering') {
          stickman.rightArmAngle += 0.2 * stickman.armDirection;
          if (stickman.rightArmAngle > 0.8 || stickman.rightArmAngle < -0.8) stickman.armDirection *= -1;
          stickman.leftArmAngle = -0.3;
          stickman.leftLegAngle = 0.2;
          stickman.rightLegAngle = -0.2;
        } else {
          stickman.leftArmAngle = 0.3;
          stickman.rightArmAngle = -0.3;
          stickman.leftLegAngle = 0.2;
          stickman.rightLegAngle = -0.2;
        }
      } else if (finished && !highFive) {
        // Move towards each other for high-five
        const midPoint = (stickman1.x + stickman2.x) / 2;
        if (stickman1.x < midPoint - 10) {
          stickman1.x += 2;
          stickman1.leftArmAngle += 0.1 * stickman1.armDirection;
          stickman1.rightArmAngle -= 0.1 * stickman1.armDirection;
          stickman1.leftLegAngle += 0.15 * stickman1.legDirection;
          stickman1.rightLegAngle -= 0.15 * stickman1.legDirection;
        }
        if (stickman2.x > midPoint + 10) {
          stickman2.x -= 2;
          stickman2.leftArmAngle += 0.1 * stickman2.armDirection;
          stickman2.rightArmAngle -= 0.1 * stickman2.armDirection;
          stickman2.leftLegAngle += 0.15 * stickman2.legDirection;
          stickman2.rightLegAngle -= 0.15 * stickman2.legDirection;
        }
        if (Math.abs(stickman1.x - stickman2.x) <= 30) {
          highFive = true;
          stickman1.leftArmAngle = 0;
          stickman1.rightArmAngle = 0;
          stickman2.leftArmAngle = 0;
          stickman2.rightArmAngle = 0;
        }
      }

      if (highFive) {
        // High-five animation
        stickman1.rightArmAngle += 0.1;
        stickman2.leftArmAngle -= 0.1;
        if (stickman1.rightArmAngle > 1.2) stickman1.rightArmAngle = 1.2;
        if (stickman2.leftArmAngle < -1.2) stickman2.leftArmAngle = -1.2;
        stickman1.leftLegAngle = 0.2;
        stickman1.rightLegAngle = -0.2;
        stickman2.leftLegAngle = 0.2;
        stickman2.rightLegAngle = -0.2;
      }
    }

    function update() {
      if (!finished) {
        if (building) {
          blockCounter++;
          const letter = letters[currentLetterIndex];
          if (letter) {
            const totalBlocks = letter.flat().filter(b => b === 1).length;
            if (blockCounter >= totalBlocks) {
              currentLetterIndex++;
              blockCounter = 0;
              building = false;
              stickman1.speed = 2;
              stickman2.speed = 2;
              if (currentLetterIndex >= letters.length) {
                finished = true;
              }
            }
          }
        }
      }
      updateStickman(stickman1);
      updateStickman(stickman2);
    }

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawStickman(stickman1);
      drawStickman(stickman2);
      drawLetters();
      update();
      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>